## React, Vue, Svelte… 변화하는 프레임워크 속에서 컴포넌트 발전하기
### 목차
1. [우리가 해결하고 싶었던 문제](#우리가-해결하고-싶었던-문제)
2. [새로운 고민들](#새로운-고민들)
3. [다른 타입의 Cross Framework Component](#다른-타입의-cross-framework-component)
4. [새로 생기고 발전하는 프레임워크](#새로-생기고-발전하는-프레임워크)
5. [그리고 이후](#그리고-이후)

### 우리가 해결하고 싶었던 문제
- 다양한 개발 환경
  - jQuery에서 프레임워크로의 전환
  - 기능은 그대로인 상태에서 개발 환경 전환
  - 기존과 같은 기능을 하는 컴포넌트는 프레임워크에 없음
  - 프레임워크에서 지원하는 컴포넌트에 맞게 기능을 개발
  
- 프레임워크의 선정에따라 지원하는 UI 및 기능이 변경되는 문제
  - 그냥 JS로 작성한 컴포넌트를 각 프레임워크에서 사용할 수 있도록 Wrapping
  - 프레임워크의 개발 방법과 기존 방법의 차이가 매우 큼
  - 프레임워크 기반의 개발은 직접 DOM을 조작하지 않음
  - 직접 DOM을 조작하는 기존의 개발방식은 적합하지 않음

- 프레임워크에서의 개발 방법을 컴포넌트에 적용
  - 프레임워크에 DOM 조작을 위임, 컴포넌트는 변경된 DOM을 동기화
  - 컴포넌트는 DOM 조작을 추상화 하여 JS에서 직접, 프레임워크에서는 위임하게됨

- Cross Framework Component
   - 대부분 프레임워크는 유사한 Life Cycle를 가짐
  - DOM에 접근 가능한 이벤트에 JS를 초기화
  - 변화는 감지할 때 DOM을 비교해 컴포넌트에 반영
  - 이로 인해 새로운 프레임워크에 대응이 빠름

### 새로운 고민들
#### **DOM DIFF**   
CFC에서는 DOM Diff 과정이 매우 많이 발생함, 프레임워크에서는 변화를 JS에서 동기화 하는 과정이 필요했고 동기화 되는 과정은 매우 자주 발생하게됨, 이 부분을 개선하면 전반적인 개선이 가능해짐,

그로인해 나온 해결법은 바로  ```Longest Incresing Subsequence```임
개선 결과, **비교 시간 33%, DOM 조작 시간 67%** 개선됨

#### **Server-Side-Rending**
기존 JS에서는 서버에서 렌더링이 완료된 DOM을 가지고 핸들링하였지만 프레임워크에서는 **Client와 Server가 같은 코드를 렌더링**하고 **SSR에서 DOM접근법이 프레임워크마다 다르기때문**에 따로 개발이 필요해짐

#### **State Restore(상태복구)**
상태를 복구하는 기능은 UX적으로 중요한 기능, 일반적으로 사용자가 상품을 보다가 클릭해서 상세정보를 확인 후 뒤로가기를 누르게되면 페이지의 제일 위가 아닌 **상품을 보던 시점으로 복귀되기를 원함,**    
기존 JS에서는 ```BFCache``` 와 ```History.scrollRestoration``` 이 합쳐지면 해결되지만 브라우저 종류나 버전에 따라 바뀌는점이 많기에 네이버팀에서는 JS로 구현했어야했음,    

상태복구를 위해 필요한 정보는 그 시점에서의 컴포넌트 상태 정보와 HTML임, 
페이지를 떠날 때 ```getStatus```로 ```restore```정보를 얻고 ```LocalStorage```에 저장, 페이지에 돌아올 때 ```LocalStorage```에서 정보를 찾아 ```setStatus```로 상태를 복구하는 방법을 생각하여 시도했으나 CFC에서 발생했던 컴포넌트와 프레임워크간의 **DOM Sync 문제가 발생**함, 프레임워크에서 페이지를 떠날 때 **HTML만 저장하지 않고 각종 Status와 Data를 저장하는 방식으로 해결**

### 다른 타입의 Cross Framework Component
CFC에서 DOM 동기화가 필요한 컴포넌트 이외에 2가지 추가 타입이 생겼음,
- [```Dynamic DOM```](#dynamic-dom): 컴포넌트 DOM정보와 프레임워크의 DOM정보를 동기화 해야 하는 경우
- [```Reactive DOM```](#reactive-dom): 상태의 변화만 감지하는 경우
- [```Static DOM```](#static-dom): 컴포넌트에서 초기 이외의 DOM정보를 동기화 하지 않아도 되는 경우

#### Dynamic DOM
Flicking이나 InfiniteGrid같이 **아이템을 추가하고 삭제하는 컴포넌트**는 DOM을 핸들링 해야함, 프레임워크용 컴포넌트를 만들 때는 컴포넌트에서 DOM을 핸들링하지 않고, 프레임워크로 위임 후 라이프 사이클에서 동기화 해야함

#### Reactive DOM
ImReady와 같이 **DOM을 직접 핸들링하지 않고 상태의 변화만 알리는 경우**라면 일반 컴포넌트 방식 보다 프레임워크에서 제공하는 적절한 기능을 이용
- React에서는 ```Hooks```
- Vue2에서는 ```Composition API```
- Vue3에서는 ```Reactive```
- Angular에서는 ```Directive```
- Svelte에서는 ```Store```

#### Static DOM
**한번 로딩되면 컴포넌트 내부에서 모두 처리되는 컴포넌트**로 View360, View3D같이 로딩 이후 **DOM의 동기화가 필요하지 않은 컴포넌트**를 말함, 각 프레임워크에서 쉽게 사용할 수 있도록 살짝 감싸는게 좋음, 옵션은 Prop으로 처리



### 새로 생기고 발전하는 프레임워크
#### Preact
**Preact는 사실 React와 다르지 않음,**
- Preact컴포넌트는 ```React 컴포넌트```를 사용
- ```preact-compat```을 사용 가능
- ```rollup-plugin-preact```로 변환 가능

#### Vue2 & Vue3를 같이 적용하기(컴포넌트 개발 관점)
**결론:** 같이 적용하기 힘듦 두 버전으로 지원함   
**이유:** 많은 부분이 달라짐, ```Global API```, ```Template문법``` 등등   
**그래도 사용하려면:** Global API, Template문법등을 사용하지 않고 **제약하면 일부 가능**

#### Svelte
```2019 ~ 2020년```부터 ```Svelte```가 떠올라서 지원하기로 함, 지원하면서 생긴 여러이슈들이 있음
- **DOM 상태 정보의 접근 문제**   
  - DOM 상태를 접근할 수 없어, 별도의 FlickingPanel 같은 컴포넌트로 해결

- **DOM의 변경 문제**   
  - 컴포넌트의 렌더링 되는 엘리먼트를 지정 없이, ```div로 렌더링```
  DOM 순서를 변경할 수 없어 ```CSS의 order```로 변경함, 그러나 그로 인해 브라우저 커버리지가 IE10+로 낮아짐

#### Vanilla JS의 메서드 확장 이슈
Svelte에서는 ```Prototype으로 접근이 안됨```, svelte에서는 ```instance를 반환```하기에 ```외부에서 Prototype으로 확장```해야했음.

### 그리고 이후
#### 추세
- 전체 다운로드 수 대비 프레임워크를 지원하는 컴포넌트의 프레임워크 다운로드 수는 **약 절반정도**
- 프레임워크 내부에서 보자면 **React를 높지만 하락세**, **Vue와 Svelte 상승세**를 보이고 있음
- 절반정도가 프레임워크 다운로드이기에 **egjs의 컴포넌트들은 모두 CFC로 전환중**
#### DOCS
- 기능이 점점많아져서 JSDoc에서 CFC를 표현하기가 아쉬움 (프레임워크별 예제 등)
- 그에따라 Docusaurus로 전환(다양한 템플릿, 확장성 등)

#### Demo
- 인터랙티브하게 값을 변경하면서 확인할 수 있는 데모가 필요, StoryBook이 가장 이상적임

#### TESTING
- Vanilla JS가 정상적으로 동작한다고 모든 프레임워크에서 동작한다고 보장할 수 없음,
- 그렇기에 **프레임워크 데모를 만들고 이를 E2E 테스트로 대응**
